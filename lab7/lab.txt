Name: Omar Ozgur
ID: 704465898
Date: 02/22/2016
Lab Section: 3
TA: Lauren Samy

*** Assignment 7 ***

Laboratory Log:

In order to begin the laboratory assignment, I logged onto a UCLA Seasnet
server by using the following command:
	ssh ozgur@lnxsrv09.seas.ucla.edu

Next, I created two files, tr2b.c and tr2bu.c by using the "touch" command.

In order to get the command lines in each file, I used the parameters
"int argc, char *argv[]" in the main function. This allowed for me to
reference the first command line argument by accessing "argv[1]", and the
second argument by accessing "argv[2]". This is due to the fact that "argv[0]"
is used to store the name of the program that is running.

After finding the 2 command line arguments for the program, I checked the sizes
and contents to make sure that the arguments contained the same number of
characters, and that the first argument did not have any duplicate elements.

The part of the program that translated characters based on the 2 command line
arguments differed in the two program implementations.

In the "tr2.c" buffered implementation of the program, the "getchar()"
function from the "stdio.h" library was used to read one character at a time.
A "for" loop was used to check if each character from standard input was
present in the first argument of the program. If a translation for the
character was found, the "putchar()" function was used to print the translated
version to standard output. Otherwise, the untranslated character was printed
by using the same function. This process continued until the "getchar()"
function encountered an EOF signal. The "getchar()" and "putchar()" functions
use buffered I/O in order to reduce the number of system calls that are made
in a program.

In the "tr2u.c" unbuffered implementation of the program, the "read()" function
from the "unistd.h" library was used to read one character at a time to a
single-character array. A "for" loop was used to check if each character from
standard input had an available translation. If such a translation was found,
the "write()" function was used to print the translated character to standard
output. Otherwise, the untranslated character was printed. This process
continued until the "read()" function returned a value that was less than or
equal to 0. The "read()" and "write()" functions do not use buffered I/O, and
rely on system calls to perform operations every time that these functions
are called.

After creating the two implementations of the program, the files were compiled
by using gcc. In order to compare the performance of each of the
implementations, a large text file "test.txt" of approximately 5 MB was
generated by using the following command:
	dd if=/dev/urandom of=test.txt bs=1M count=5

In order to test the number of system calls that were made, the "strace" command
was utilized. The number of system calls were recorded while each of the
program implementations were run on the large text file "test.txt". This test
was done once while the output was copied to a new file "testResult.txt", and
once while the output was printed directly to the terminal screen. The commands
that were run are shown below, along with the resulting number of system calls:

	strace -o bufOutputCopy.txt ./tr2b abc xyz < test.txt > testResult.txt
	wc -l bufOutputCopy.txt
	(31 system calls)
	
	strace -o unbufOutputCopy.txt ./tr2u abc xyz < test.txt > testResult.txt
	wc -l unbufOutputCopy.txt
	(9296680 system calls)


	strace -o bufOutputTerminal.txt ./tr2b abc xyz < test.txt
	wc -l bufOutputTerminal.txt
	(31 system calls)

	
	strace -o unbufOutputTerminal.txt ./tr2u abc xyz < test.txt
	wc -l unbufOutputTerminal.txt
	(10485786 syscalls)

As can be seen by the results of the strace commands above, the buffered
version of the program used significantly less system calls than the
unbuffered version. This is due to the fact that the buffered version uses
functions that minimize the number of system calls by grouping these calls
in buffers during executions. In the unbuffered version, a system call
is made every time that a character is read or written. Based on the output
from the unbuffered version of the program, it can also be seen that writing
to the terminal screen instead of to another file normally increases the
number of system calls due to the facts that these calls are required in
order to write to the physical screen. Writing to the screen did not change
the number of system calls in the buffered program since these calls were
placed in a buffer before being executed together.

Another way to analyze the performance of the programs was to use the "time"
command to record the amount of time that it took for the programs to run while
copying output to another file, and while printing to the terminal screen.
Again, this was done while reading from the large text file "test.txt". The
commands and outputs are shown below:

	time ./tr2b abc xyz < test.txt > testResult.txt
	real	0m0.003s
	user	0m0.000s
	sys	0m0.002s

	time ./tr2b abc xyz < test.txt
	real    0m0.002s
	user    0m0.000s
	sys     0m0.001s

	time ./tr2u abc xyz < test.txt > testResult.txt
	real	0m6.033s
	user	0m0.280s
	sys	0m5.686s

	time ./tr2u abc xyz < test.txt
	real	0m8.477s
	user	0m0.274s
	sys	0m5.336s

As expected, the buffered version of the program ran much faster than the
unbuffered version. In the unbuffered case, it can be seen that writing results
to the terminal screen was slower than writing to another file. This was likely
due to the larger number of system calls that were required to write the the
screen, as indicated by the results shown earlier in the log. These commands
were run multiple times in order to ensure that the results were not outliers.

Based on these results, it is clear that buffered I/O has many benefits over
unbuffered I/O. By effectively using buffered I/O, a program can be made to
minimize system calls, and decrease execution time.
